#!/usr/bin/env node

// CLI util to collect/check current EPF files

import { mkdir, unlink } from 'node:fs/promises'
import { dirname } from 'node:path'
import chalk from 'chalk'

import { getEPFList, getEpfFileAsLocal } from './lib/remote.js'
import { exists, md5check } from './lib/utils.js'

const { green, yellow, red } = chalk

const [, , type = 'full', outDir = 'data/epf'] = process.argv

if (type === '--help') {
  console.log('Usage: download [type:update|full] [outDir=data/epf]')
  process.exit(0)
}

const urls = await getEPFList(type)

// I think these are the useful things
const goodStuff = ['application_price', 'paid_ipad_application_popularity_per_genre', 'paid_application_popularity_per_genre', 'free_ipad_application_popularity_per_genre', 'free_application_popularity_per_genre', 'storefront', 'key_value', 'genre_application', 'genre', 'device_type', 'artist_application', 'artist', 'application_device_type', 'application_detail', 'application']

for (const { group, table, date, url } of urls) {
  if (!goodStuff.includes(table)) {
    continue
  }
  const epfFile = `${outDir}/${type}/${date.getTime() / 1000}/${group}/${table}.tbz`
  const name = `${group}.${table}`
  let ok
  if (await exists(epfFile)) {
    ok = await md5check(epfFile)
  } else {
    console.log(yellow('download'), name)
    await mkdir(dirname(epfFile), { recursive: true })
    ok = await getEpfFileAsLocal(url, epfFile, true)
  }
  if (ok) {
    console.log(green('ok'), name)
  } else {
    console.log(red('bad'), name)
    try {
      unlink(epfFile)
    } catch (e) {}
  }
}
